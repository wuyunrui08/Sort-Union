# Sort-Union
排序算法总集

# 排序算法简介

---

一些排序的时间复杂度

|算法|最坏情况运行时间|平均情况/期望运行时间|
|:-:|:-:|:-:|
|插入排序|O(n^2^)|O(n^2^)|
|冒泡排序|O(n^2^)|O(n^2^)|
|归并排序|O(nlgn)|O(nlgn)|
|堆排序|O(nlgn)|------|
|快速排序|O(n^2^)|O(nlgn)(期望)|
|计数排序|O(k+n)|O(k+n)|
|基数排序|O(d(n+k))|O(d(n+k))|
|桶排序|O(n^2^)|O(n)(平均情况)|


其中不基于比较的排序：基数排序

捋一下： 
- **为什么要排序？**

---

以下便是算法导论的内容：

很多计算机科学家认为排序是算法研究中最基础的问题，其原因有很多：
- 有时应用本身就需要对信息进行排序。例如，为了准备用户财务报表，银行需要按编号对支票进行排序
- 很多算法通常把排序作为关键子程序。例如，在一个渲染图形对象的程序中，图形对象是分层叠在一起的，这个程序可能就需要按“上层”关系来排序对象，以便能按自底向上的次序绘制对象。
- 现有的排序算法数量非常庞大，其中所使用的技术也非常丰富。实际上，很多重要的算法设计技术都体现在多年来研究者所设计的排序算法中。从这个角度看，排序问题还有很好的历史价值
- 我们可以证明排序问题的一个非平凡下界。而我们的最佳上界能够与这个非平凡下界渐进平等。我们可以利用排序问题的下届来证明其他问题的下届
- 在实现排序算法时会出现很多工程问题。某个特定环境下的最快的排序算法可能依赖很多因素，例如，关于关键字和卫星数据的先验知识、计算机主机的内存层次（缓存和虚拟内存）和软件环境。很多这类问题最好在算法层面来处理，而不是通过“代码调优”来解决

---

一句话，在你需要排序的时候就是要排序的时候.....

然后后面，我们将逐渐来介绍各种上面提及排序算法，需要时间总结.......


---

借鉴《算法导论》
